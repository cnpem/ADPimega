# pimega.template
# Medipix Area Detector extensions
#
#
# Parameters:
#% macro, P,        EPICS name prefix
#% macro, R,        EPICS name suffix
#% macro, PORT,     Asyn port
#% macro, ADDR,     Asyn Address
#% macro, TIMEOUT,  Asyn communications timeout
#% macro, XSIZE,    Maximum size of X histograms
#% macro, YSIZE,    Maximum size of Y histograms

# This associates the template with an edm screen
# % gui, $(PORT), edmtab, pimegaDetector.edl, P=$(P),R=$(R)
##  gdatag, template, pimega, $(PORT)_pimega, pimega detector

include "ADBase.template"

##########################################################################
# Disable records from ADBase etc. that we do not use for pimega
##########################################################################

record(waveform, "$(P)$(R)ArrayData")
{
	field(SCAN, "2 second")
}


record(calcout,"$(P)$(R)UpdateScan")
{
	field(INPA, "$(P)$(R)Acquire CPP NMS")
	field(CALC, "(A)==1?2:4")
	field(OUT,  "$(P)$(R)TemperatureActual.SCAN PP")

}
record(ao, "$(P)$(R)Gain")
{
	#field(DISA, "1")
}

record(ai, "$(P)$(R)Gain_RBV")
{
	#field(DISA, "1")
}

record(ai, "$(P)$(R)TimeRemaining_RBV")
{
	field(SCAN, ".1 second")
   	field(EGU, "s")
}

record(longin, "$(P)$(R)NumImagesCounter_RBV")
{
	field(SCAN, ".1 second")	
}

# We redefine the states for the TriggerMode records defined in ADBase.template
record(mbbo,"$(P)$(R)TriggerMode") {
	field(DESC,"Trigger mode")
    field(ZRVL,"0")
    field(ZRST,"Debug Push Button")
    field(ONVL,"1")
    field(ONST,"External I/O")
    field(TWVL,"2")
    field(TWST,"MCU GPIO (in-system)")
    field(IVOA, "Don't drive outputs")
}

record(mbbi,"$(P)$(R)TriggerMode_RBV") {
    field(DESC,"Trigger mode")
    field(ZRVL,"0")
    field(ZRST,"Debug Push Button")
    field(ONVL,"1")
    field(ONST,"External I/O")
    field(TWVL,"2")
    field(TWST,"MCU GPIO (in-system)")
}

# Add new items for the ImageMode records defined in ADBase.template
record(mbbo,"$(P)$(R)ImageMode") {
	field(THST,"Threshold")
	field(THVL,"3")
	field(FRST,"TestPulse")
	field(FRVL,"4")
}

record(mbbi,"$(P)$(R)ImageMode_RBV") {
	field(THST,"Threshold")
	field(THVL,"3")
	field(FRST,"TestPulse")
	field(FRVL,"4")
}

record(ao, "$(P)$(R)AcquireTime")
{
	field(DRVH, "1000")
	field(DRVL, "1e-6")
}


#e-Fuse chip ID
record(ai, "$(P)$(R)eFuseID_RBV")
{
	field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))EFUSE_ID")
    field(SCAN, "I/O Intr")
}

#SensorBias
record(ao, "$(P)$(R)SensorBias") {
	field(DESC, "Sensor Bias Voltage")
	field(DTYP, "asynFloat64")
	field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))SENSOR_BIAS")
	field(VAL, "85")
	field(PINI, "YES")

}

record(ai, "$(P)$(R)SensorBias_RBV") {
	field(DESC, "Sensor Bias Voltage Readback")
	field(DTYP, "asynFloat64")
	field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))SENSOR_BIAS")
	field(SCAN, "I/O Intr")
}

# Read Counter
record(mbbo, "$(P)$(R)ReadCounter") {
	field(DESC, "Selects the counter(s) to be read")
	field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))READ_COUNTER")
	field(PINI, "YES")
	field(DTYP, "asynInt32")
	field(VAL, "0")
	field(ZRST, "Counter Low")      field(ZRVL, "0")
	field(ONST, "Counter High")     field(ONVL, "1")
	field(TWST, "Both Counters")	field(TWVL, "2")
	field(THSV, "INVALID")
	field(FRSV, "INVALID")
    field(FVSV, "INVALID")
    field(SXSV, "INVALID")
    field(SVSV, "INVALID")
    field(EISV, "INVALID")
    field(NISV, "INVALID")
    field(TESV, "INVALID")
    field(ELSV, "INVALID")
    field(TVSV, "INVALID")
    field(TTSV, "INVALID")
    field(FTSV, "INVALID")
    field(FTSV, "INVALID")
    field(FFSV, "INVALID")
    field(IVOA, "1")
}

record(mbbi, "$(P)$(R)ReadCounter_RBV") {
	field(DTYP, "asynInt32")
	field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))READ_COUNTER")
	field(DESC, "Selects the counter(s) to be read RBV")
	field(ZRST, "Counter Low")      field(ZRVL, "0")
	field(ONST, "Counter High")     field(ONVL, "1")
	field(TWST, "Both Counters")	field(TWVL, "2")
	field(SCAN, "I/O Intr")
}

# OMR Operation mode
record(mbbo,"$(P)$(R)OmrOMSelec") {
	field(PINI, "YES")
	field(DTYP, "asynInt32")
	field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))OMR_OP_MODE")
	field(DESC, "OMR operation mode selection")
    field(ZRVL,"0")
    field(ONVL,"1")
    field(TWVL,"2")
    field(THVL,"3")
    field(FRVL,"4")
    field(FVVL,"5")
    field(SXVL,"6")
    field(SVVL,"7")
    field(ZRST, "Read Counter Low")
    field(ONST, "Read Counter High")
    field(TWST, "Load Counter Low")
    field(THST, "Load Counter High")
    field(FRST, "Load DACs")
    field(FVST, "Load CTPR")
    field(SXST, "Read DACs")
    field(SVST, "Read OMR and ID")
    field(VAL, "1")
}

record(mbbi,"$(P)$(R)OmrOMSelec_RBV") {
   	field(DTYP, "asynInt32")
   	field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))OMR_OP_MODE")
    field(DESC, "OMR  operation mode selection readback")
    field(ZRVL,"0")
    field(ONVL,"1")
    field(TWVL,"2")
    field(THVL,"3")
    field(FRVL,"4")
    field(FVVL,"5")
    field(SXVL,"6")
    field(SVVL,"7")
   	field(ZRST, "Read Counter Low")
    field(ONST, "Read Counter High")
    field(TWST, "Load Counter Low")
    field(THST, "Load Counter High")
    field(FRST, "Load DACs")
    field(FVST, "Load CTPR")
    field(SXST, "Read DACs")
    field(SVST, "Read OMR and ID")
   	field(SCAN, "I/O Intr")
}

# Gain mode - Selects the sensor gain mode
record(mbbo,"$(P)$(R)GainMode") {
   	field(PINI, "YES")
   	field(DTYP, "asynInt32")
   	field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))GAIN_MODE")
    field(DESC, "Sensor gain mode")
    field(ZRVL, "0")
    field(ZRST, "Super High gain")
    field(ONVL, "1")
    field(ONST, "Low gain")
    field(TWVL, "2")
    field(TWST, "High gain")
    field(THVL, "3")
    field(THST, "Super Low gain")
}

record(mbbi,"$(P)$(R)GainMode_RBV") {
   	field(DTYP, "asynInt32")
   	field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))GAIN_MODE")
    field(DESC, "Sensor gain mode readback")
    field(ZRVL, "0")
    field(ZRST, "Super High gain")
    field(ONVL, "1")
    field(ONST, "Low gain")
    field(TWVL, "2")
    field(TWST, "High gain")
    field(THVL, "3")
    field(THST, "Super Low gain")
   	field(SCAN, "I/O Intr")
}

# Sense Dac Selection
record(ao, "$(P)$(R)SenseDacSel")
{
	field(DESC, "Select DAC code to be monitored")
	field(PINI, "YES")
   	field(DTYP, "asynInt32")
   	field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))SENSE_DAC_SEL")
   	field(VAL,  "0")
}

record(ai, "$(P)$(R)SenseDacSel_RBV")
{
   	field(DESC, "Select DAC code to be monitored readback")
   	field(DTYP, "asynInt32")
   	field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))SENSE_DAC_SEL")
   	field(SCAN,  "I/O Intr")
}

record(bo,"$(P)$(R)ContinuousRW") {
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))CONTINUOUSRW")
    field(DESC, "Enable Continuous Read/Write")
    field(ZNAM, "Disable(Sequential)")
    field(ONAM, "Enable(Continuous)")
}

record(bi,"$(P)$(R)ContinuousRW_RBV") {
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))CONTINUOUSRW")
    field(DESC, "Enable Continuous Read/Write")
    field(ZNAM, "Disable(Sequential)")
    field(ONAM, "Enable(Continuous)")
    field(SCAN, "I/O Intr")
}

record(bo,"$(P)$(R)Polarity") {
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))POLARITY")
    field(DESC, "Select pixel polarity")
    field(ZNAM, "Electrons")
    field(ONAM, "Holes")
    field(VAL,  "1")
}

record(bi,"$(P)$(R)Polarity_RBV") {
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))POLARITY")
    field(DESC, "Select pixel polarity Readback")
    field(ZNAM, "Electrons")
    field(ONAM, "Holes")
    field(SCAN, "I/O Intr")
}

record(bo,"$(P)$(R)Discriminator") {
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))DISCRIMINATOR")
    field(DESC, "Select energy discriminator output")
    field(ZNAM, "Discriminator LOW")
    field(ONAM, "Discriminator HIGH")
    field(VAL,  "0")
}

record(bi,"$(P)$(R)Discriminator_RBV") {
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))DISCRIMINATOR")
    field(DESC, "Select energy discriminator output RBV")
    field(ZNAM, "Discriminator LOW")
    field(ONAM, "Discriminator HIGH")
    field(SCAN, "I/O Intr")
}

record(bo,"$(P)$(R)TestPulse") {
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))TEST_PULSE")
    field(DESC, "Enable test pulse")
    field(ZNAM, "Disabled")
    field(ONAM, "Enabled")
}

record(bi,"$(P)$(R)TestPulse_RBV") {
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))TEST_PULSE")
    field(DESC, "Enable test pulse readback")
    field(ZNAM, "Disabled")
    field(ONAM, "Enabled")
    field(SCAN, "I/O Intr")
}

# Counter depth - number of bits per pixel
record(mbbo,"$(P)$(R)CounterDepth") {
   	field(PINI, "YES")
   	field(DTYP, "asynInt32")
   	field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))COUNTER_DEPTH")
    field(DESC, "Number of bits per pixel")
    field(ZRVL, "0")
    field(ZRST, "1 bit")
    field(ONVL, "1")
    field(ONST, "12 bits")
    field(TWVL, "2")
    field(TWST, "6 bits")
    field(THVL, "3")
	field(THST, "24 bits")
    field(VAL, "1")
    field(FRSV, "INVALID")
    #field(FVSV, "INVALID")
    #field(SXSV, "INVALID")
    field(SVSV, "INVALID")
    field(EISV, "INVALID")
    field(NISV, "INVALID")
    field(TESV, "INVALID")
    field(ELSV, "INVALID")
    field(TVSV, "INVALID")
    field(TTSV, "INVALID")
    field(FTSV, "INVALID")
    field(FTSV, "INVALID")
    field(FFSV, "INVALID")
    field(IVOA, "1")
}

record(mbbi,"$(P)$(R)CounterDepth_RBV") {
   	field(DTYP, "asynInt32")
   	field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))COUNTER_DEPTH")
    field(DESC,"Number of bits per pixel")
    field(ZRVL, "0")
    field(ZRST, "1 bit")
    field(ONVL, "1")
    field(ONST, "12 bits")
    field(TWVL, "2")
    field(TWST, "6 bits")
    field(THVL, "3")
    field(THST, "24 bits")
   	field(SCAN, "I/O Intr")
}

record(bo,"$(P)$(R)Equalization") {
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))EQUALIZATION")
    field(DESC, "Threshold Equalization mode")
    field(ZNAM, "Equalization OFF")
    field(ONAM, "Equalization ON")
}

record(bi,"$(P)$(R)Equalization_RBV") {
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))EQUALIZATION")
    field(DESC, "Threshold Equalization mode readback")
    field(ZNAM, "Equalization OFF")
    field(ONAM, "Equalization ON")
    field(SCAN, "I/O Intr")
}

record(bo,"$(P)$(R)PixelMode") {
    field(DESC, "Pixel Mode count photons per pixel")
    field(DTYP, "asynInt32")
   	field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))PIXEL_MODE")
    field(ZNAM, "Single Pixel Mode")
    field(ONAM, "Charge Summing Mode")
}

record(bi,"$(P)$(R)PixelMode_RBV") {
    field(DESC, "Pixel Mode count photons per pixel")
    field(DTYP, "asynInt32")
	field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))PIXEL_MODE")
    field(ZNAM, "Single Pixel Mode")
    field(ONAM, "Charge Summing Mode")
    field(SCAN, "I/O Intr")
}

record(ao, "$(P)$(R)MedipixBoard")
{
	field(DESC, "Medipix Board Number")
	#field(PINI, "YES")
   	field(DTYP, "asynInt32")
   	field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))MEDIPIX_BOARD")
   	#field(VAL,  "0")
}

record(ai, "$(P)$(R)MedipixBoard_RBV")
{
	field(DESC, "Medipix Board Number Readback")
   	field(DTYP, "asynInt32")
   	field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))MEDIPIX_BOARD")
   	field(SCAN,  "I/O Intr")
}

record(ao, "$(P)$(R)ImgChipNumberID")
{
	field(DESC, "Image Chip Number ID")
	#field(PINI, "YES")
   	field(DTYP, "asynInt32")
   	field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))MEDIPIX_CHIP")
   	#field(VAL,  "1")
}

record(ai, "$(P)$(R)ImgChipNumberID_RBV")
{
   	field(DESC, "Image Chip Number ID readback")
   	field(DTYP, "asynInt32")
   	field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))MEDIPIX_CHIP")
   	field(SCAN,  "I/O Intr")
}


record(bo, "$(P)$(R)Reset")
{
	field(DTYP, "asynInt32")
	field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))RESET")
	field(ZNAM, "0")
	field(ONAM, "1")
}

record(ai, "$(P)$(R)DAC_Bias_RBV")
{
	field(DTYP, "asynInt32")
	field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))DAC_BIAS")
	field(DESC, "External DAC Bias monitor readback")
	field(SCAN, "I/O Intr")

}

record(ai, "$(P)$(R)DAC_ThresholdEnergy0_RBV")
{
	field(DTYP, "asynInt32")
	field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))THRESHOLD0")
	field(DESC, "Threshold 0 for photon detection")
	field(SCAN, "I/O Intr")
}

record(ao, "$(P)$(R)DAC_ThresholdEnergy0")
{
	field(DTYP, "asynInt32")
	field(OUT, "@asyn($(PORT),$(ADDR),$(TIMEOUT))THRESHOLD0")
	field(DESC, "Threshold 0 for photon detection")
}

record(ai, "$(P)$(R)DAC_ThresholdEnergy1_RBV")
{
	field(DTYP, "asynInt32")
	field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))THRESHOLD1")
	field(DESC, "Threshold 1 for photon detection")
	field(SCAN, "I/O Intr")
}

record(ao, "$(P)$(R)DAC_ThresholdEnergy1")
{
	field(DTYP, "asynInt32")
	field(OUT, "@asyn($(PORT),$(ADDR),$(TIMEOUT))THRESHOLD1")
	field(DESC, "Threshold 1 for photon detection")
}

record(ai, "$(P)$(R)DAC_Preamp_RBV")
{
	field(DTYP, "asynInt32")
	field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))PREAMP")
	field(DESC, "Preamplifier current")
	field(SCAN, "I/O Intr")
}

record(ao, "$(P)$(R)DAC_Preamp")
{
	field(DTYP, "asynInt32")
	field(OUT, "@asyn($(PORT),$(ADDR),$(TIMEOUT))PREAMP")
	field(DESC, "Preamplifier current")
}

record(ai, "$(P)$(R)DAC_IKrum_RBV")
{
	field(DTYP, "asynInt32")
	field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))IKRUM")
	field(DESC, "Krummenacher current")
	field(SCAN, "I/O Intr")
}

record(ao, "$(P)$(R)DAC_IKrum")
{
	field(DTYP, "asynInt32")
	field(OUT, "@asyn($(PORT),$(ADDR),$(TIMEOUT))IKRUM")
	field(DESC, "Krummenacher current")
}

record(ai, "$(P)$(R)DAC_Shaper_RBV")
{
	field(DTYP, "asynInt32")
	field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))SHAPER")
	field(DESC, "Shaper current")
	field(SCAN, "I/O Intr")
}

record(ao, "$(P)$(R)DAC_Shaper")
{
	field(DTYP, "asynInt32")
	field(OUT, "@asyn($(PORT),$(ADDR),$(TIMEOUT))SHAPER")
	field(DESC, "Shaper current")
}

record(ai, "$(P)$(R)DAC_Disc_RBV")
{
	field(DTYP, "asynInt32")
	field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))DISC")
	field(DESC, "Discriminator current")
	field(SCAN, "I/O Intr")
}

record(ao, "$(P)$(R)DAC_Disc")
{
	field(DTYP, "asynInt32")
	field(OUT, "@asyn($(PORT),$(ADDR),$(TIMEOUT))DISC")
	field(DESC, "Discriminator current")
}

record(ai, "$(P)$(R)DAC_DiscLS_RBV")
{
	field(DTYP, "asynInt32")
	field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))DISC_LS")
	field(SCAN, "I/O Intr")
}

record(ao, "$(P)$(R)DAC_DiscLS")
{
	field(DTYP, "asynInt32")
	field(OUT, "@asyn($(PORT),$(ADDR),$(TIMEOUT))DISC_LS")
}

record(ai, "$(P)$(R)DAC_DiscL_RBV")
{
	field(DTYP, "asynInt32")
	field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))DISC_L")
	field(SCAN, "I/O Intr")
	field(DESC, "Low discriminator current")
}

record(ao, "$(P)$(R)DAC_DiscL")
{
	field(DTYP, "asynInt32")
	field(OUT, "@asyn($(PORT),$(ADDR),$(TIMEOUT))DISC_L")
	field(DESC, "Low discriminator current")
}

record(ai, "$(P)$(R)DAC_Delay_RBV")
{
	field(DTYP, "asynInt32")
	field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))DELAY")
	field(SCAN, "I/O Intr")
}

record(ao, "$(P)$(R)DAC_Delay")
{
	field(DTYP, "asynInt32")
	field(OUT, "@asyn($(PORT),$(ADDR),$(TIMEOUT))DELAY")
}

record(ai, "$(P)$(R)DAC_TPBufferIn_RBV")
{
	field(DTYP, "asynInt32")
	field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))TP_BUFFER_IN")
	field(DESC, "Test pulse input buffer current")
	field(SCAN, "I/O Intr")
}

record(ao, "$(P)$(R)DAC_TPBufferIn")
{
	field(DTYP, "asynInt32")
	field(OUT, "@asyn($(PORT),$(ADDR),$(TIMEOUT))TP_BUFFER_IN")
	field(DESC, "Test pulse input buffer current")
}

record(ai, "$(P)$(R)DAC_TPBufferOut_RBV")
{
	field(DTYP, "asynInt32")
	field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))TP_BUFFER_OUT")
	field(DESC, "Test pulse output buffer current")
	field(SCAN, "I/O Intr")
}

record(ao, "$(P)$(R)DAC_TPBufferOut")
{
	field(DTYP, "asynInt32")
	field(OUT, "@asyn($(PORT),$(ADDR),$(TIMEOUT))TP_BUFFER_OUT")
	field(DESC, "Test pulse output buffer current")
}

record(ai, "$(P)$(R)DAC_RPZ_RBV")
{
	field(DTYP, "asynInt32")
	field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))RPZ")
	field(DESC, "Shaper pole zero voltage")
	field(SCAN, "I/O Intr")
}

record(ao, "$(P)$(R)DAC_RPZ")
{
	field(DTYP, "asynInt32")
	field(OUT, "@asyn($(PORT),$(ADDR),$(TIMEOUT))RPZ")
	field(DESC, "Shaper pole zero voltage")
}

record(ai, "$(P)$(R)DAC_GND_RBV")
{
	field(DTYP, "asynInt32")
	field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))GND")
	field(DESC, "Preamplifier virtual ground voltage")
	field(SCAN, "I/O Intr")
}

record(ao, "$(P)$(R)DAC_GND")
{
	field(DTYP, "asynInt32")
	field(OUT, "@asyn($(PORT),$(ADDR),$(TIMEOUT))GND")
	field(DESC, "Preamplifier virtual ground voltage")
}

record(ai, "$(P)$(R)DAC_TPRef_RBV")
{
	field(DTYP, "asynInt32")
	field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))TP_REF")
	field(DESC, "Test pulses 1 and 2 reference voltage")
	field(SCAN, "I/O Intr")
}

record(ao, "$(P)$(R)DAC_TPRef")
{
	field(DTYP, "asynInt32")
	field(OUT, "@asyn($(PORT),$(ADDR),$(TIMEOUT))TP_REF")
	field(DESC, "Test pulses 1 and 2 reference voltage")
}

record(ai, "$(P)$(R)DAC_FBK_RBV")
{
	field(DTYP, "asynInt32")
	field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))FBK")
	field(DESC, "Preamplifier feedback voltage")
	field(SCAN, "I/O Intr")
}

record(ao, "$(P)$(R)DAC_FBK")
{
	field(DTYP, "asynInt32")
	field(OUT, "@asyn($(PORT),$(ADDR),$(TIMEOUT))FBK")
	field(DESC, "Preamplifier feedback voltage")
}

record(ai, "$(P)$(R)DAC_CAS_RBV")
{
	field(DTYP, "asynInt32")
	field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))CAS")
	field(DESC, "DAC cascode bias")
	field(SCAN, "I/O Intr")
}

record(ao, "$(P)$(R)DAC_CAS")
{

	field(DTYP, "asynInt32")
	field(OUT, "@asyn($(PORT),$(ADDR),$(TIMEOUT))CAS")
	field(DESC, "DAC cascode bias")
	field(DRVL, 0)
	field(DRVH, 255)
}

record(ai, "$(P)$(R)DAC_TPRefA_RBV")
{
	field(DTYP, "asynInt32")
	field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))TP_REF_A")
	field(DESC, "Test pulse 1 voltage")
	field(SCAN, "I/O Intr")
}

record(ao, "$(P)$(R)DAC_TPRefA")
{
	field(DTYP, "asynInt32")
	field(OUT, "@asyn($(PORT),$(ADDR),$(TIMEOUT))TP_REF_A")
	field(DESC, "Test pulse 1 voltage")
}

record(ai, "$(P)$(R)DAC_TPRefB_RBV")
{
	field(DTYP, "asynInt32")
	field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))TP_REF_B")
	field(DESC, "Test pulse 2 voltage")
	field(SCAN, "I/O Intr")
}

record(ao, "$(P)$(R)DAC_TPRefB")
{
	field(DTYP, "asynInt32")
	field(OUT, "@asyn($(PORT),$(ADDR),$(TIMEOUT))TP_REF_B")
	field(DESC, "Test pulse 2 voltage")
}

record(ai, "$(P)$(R)DAC_DiscH_RBV")
{
	field(DTYP, "asynInt32")
	field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))DISC_H")
	field(SCAN, "I/O Intr")
	field(DESC, "High discriminator current")
}

record(ao, "$(P)$(R)DAC_DiscH")
{
	field(DTYP, "asynInt32")
	field(OUT, "@asyn($(PORT),$(ADDR),$(TIMEOUT))DISC_H")
	field(DESC, "High discriminator current")
}

record(ai, "$(P)$(R)Backend_BufferUsed_RBV")
{
	field(DTYP, "asynInt32")
	field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))BACK_BUFFER")
	field(SCAN, ".1 second")
	field(DESC, "Backend buffer used")
	field(EGU, "%")
}
